var documenterSearchIndex = {"docs":
[{"location":"generated/slack_load/","page":"slack_load","title":"slack_load","text":"EditURL = \"https://github.com/hexaeder/EMTSim.jl/blob/main/examples/slack_load.jl\"","category":"page"},{"location":"generated/slack_load/#Disconnect-load-from-slack","page":"slack_load","title":"Disconnect load from slack","text":"","category":"section"},{"location":"generated/slack_load/","page":"slack_load","title":"slack_load","text":"In this example, we examine the voltage transient of the system after a single load of constant P is disconnected from a slack.","category":"page"},{"location":"generated/slack_load/","page":"slack_load","title":"slack_load","text":"using EMTSim\nusing BlockSystems\nusing ModelingToolkit\nusing NetworkDynamics\nusing Graphs\nusing OrdinaryDiffEq\nusing DiffEqCallbacks\nusing SteadyStateDiffEq\nusing Plots\nusing Unitful\nusing CSV\nusing DataFrames","category":"page"},{"location":"generated/slack_load/#Constants-and-unit-stuff.","page":"slack_load","title":"Constants and unit stuff.","text":"","category":"section"},{"location":"generated/slack_load/","page":"slack_load","title":"slack_load","text":"!!! Note     The grid is modelled in a gloabal dq-Frame without zero component. Since we     might need to introduce local dq frames for the inverters too, the global     frame is denoted by _r and _i (for real and imag part) annotations while     the local frames use _d and _q.","category":"page"},{"location":"generated/slack_load/","page":"slack_load","title":"slack_load","text":"ω0    = 2π*50u\"rad/s\"\nSbase = 300u\"MW\"\nVbase = 110u\"kV\" #* sqrt(2/3)\nIbase = Sbase/(Vbase)#* √3) # why the √3 ?\nCbase = Ibase/Vbase\nLbase = Vbase/Ibase\nRbase = (Vbase^2)/Sbase\n\nRline = 1u\"Ω\" / Rbase           |> u\"pu\"\nPload = -300u\"MW\" / Sbase       |> u\"pu\"\nRload = (1u\"pu\")^2 / Pload      |> u\"pu\" # R=U^2/P\nCline = (2e-6)u\"F\" / Cbase      |> u\"s\"\nLline = (1/100π)u\"H\" / Lbase    |> u\"s\"\n\nnothing#hide","category":"page"},{"location":"generated/slack_load/#Slack-Bus","page":"slack_load","title":"Slack Bus","text":"","category":"section"},{"location":"generated/slack_load/","page":"slack_load","title":"slack_load","text":"The slack bus is modelled as a node with dot(u) = 0, i'll keep the initial voltage forever.","category":"page"},{"location":"generated/slack_load/","page":"slack_load","title":"slack_load","text":"@variables t u_r(t) u_i(t)\ndt = Differential(t)\n\nslackblock = IOBlock([dt(u_r) ~ 0, dt(u_i) ~ 0], [], [u_r, u_i]; name=:slack)","category":"page"},{"location":"generated/slack_load/","page":"slack_load","title":"slack_load","text":"create ODE Vertex from this block","category":"page"},{"location":"generated/slack_load/","page":"slack_load","title":"slack_load","text":"slack = ODEVertex(slackblock)\nnothing#hide","category":"page"},{"location":"generated/slack_load/#Constant-R-Load","page":"slack_load","title":"Constant R Load","text":"","category":"section"},{"location":"generated/slack_load/","page":"slack_load","title":"slack_load","text":"I tried to model an constan R load first using the algebraic current equation","category":"page"},{"location":"generated/slack_load/","page":"slack_load","title":"slack_load","text":"i = -frac 1 R  u","category":"page"},{"location":"generated/slack_load/","page":"slack_load","title":"slack_load","text":"This however, did not match the powerfactory results. The power factory load is purely ohmic (no phase shift) but constant in P. Since the voltage on bus 2 is slighly below 1 pu, we can not trivially calculate the corresponding resistance.","category":"page"},{"location":"generated/slack_load/","page":"slack_load","title":"slack_load","text":"@variables t i_r(t) i_i(t)\n@parameters u_r(t) u_i(t) R\nloadblock = IOBlock([i_r ~ -1/R * u_r,\n                     i_i ~ -1/R * u_i],\n                    [u_r, u_i], [i_r, i_i],\n                    name=:load)\n\n# The load is used as a current source in a `BusBar`\nbusblock = BusBar(loadblock; name=:loadbus)\nbusblock = set_p(busblock, Dict(:C=>ustrip(u\"s\", Cline), :ω0=>ustrip(u\"rad/s\", ω0)))\n\n# The `BusBar` block can be used to create an ODE Vertex\nload = ODEVertex(busblock, [:load₊R])","category":"page"},{"location":"generated/slack_load/#Constant-P-Load","page":"slack_load","title":"Constant P Load","text":"","category":"section"},{"location":"generated/slack_load/","page":"slack_load","title":"slack_load","text":"For a constant load P we may use the algebric current equation","category":"page"},{"location":"generated/slack_load/","page":"slack_load","title":"slack_load","text":"i_r = P fracu_ru_r^2 + u_i^2\ni_i = P fracu_iu_r^2 + u_i^2","category":"page"},{"location":"generated/slack_load/","page":"slack_load","title":"slack_load","text":"However, this leads to instability in the model and is hard to initialize. I guess it is not a good idea to follow each oszillation in node/condensator voltage!","category":"page"},{"location":"generated/slack_load/","page":"slack_load","title":"slack_load","text":"To circumvent the problem, we model the P load using a lowpass filter","category":"page"},{"location":"generated/slack_load/","page":"slack_load","title":"slack_load","text":"doti_r = frac1tauleft(P fracu_ru_r^2 + u_i^2 - i_rright)\ndoti_i = frac1tauleft(P fracu_iu_r^2 + u_i^2 - i_iright)","category":"page"},{"location":"generated/slack_load/","page":"slack_load","title":"slack_load","text":"whose time constant tau = frac1omega_0 is chosen in a way, that disturbances higher than the nominal grid frequency are damped.","category":"page"},{"location":"generated/slack_load/","page":"slack_load","title":"slack_load","text":"@variables t i_r(t) i_i(t)\n@parameters u_r(t) u_i(t) P τ\nloadblock = IOBlock([dt(i_r) ~ ustrip(u\"rad/s\", ω0)*(P * u_r/(u_r^2 + u_i^2) - i_r),\n                     dt(i_i) ~ ustrip(u\"rad/s\", ω0)*(P * u_i/(u_r^2 + u_i^2) - i_i)],\n                    [u_r, u_i], [i_r, i_i],\n                    name=:load)","category":"page"},{"location":"generated/slack_load/","page":"slack_load","title":"slack_load","text":"The load is used as a current source in a BusBar","category":"page"},{"location":"generated/slack_load/","page":"slack_load","title":"slack_load","text":"busblock = BusBar(loadblock; name=:loadbus)\nbusblock = set_p(busblock, Dict(:C=>ustrip(u\"s\", Cline), :ω0=>ustrip(u\"rad/s\", ω0)))","category":"page"},{"location":"generated/slack_load/","page":"slack_load","title":"slack_load","text":"The BusBar block can be used to create an ODE Vertex","category":"page"},{"location":"generated/slack_load/","page":"slack_load","title":"slack_load","text":"load = ODEVertex(busblock, [:load₊P])\n\nnothing#hide","category":"page"},{"location":"generated/slack_load/#ODE-edge-for-the-RL-Line","page":"slack_load","title":"ODE edge for the RL Line","text":"","category":"section"},{"location":"generated/slack_load/","page":"slack_load","title":"slack_load","text":"@variables t i_r(t) i_i(t)\n@parameters u_r_src(t) u_i_src(t) u_r_dst(t) u_i_dst(t) R L ω\n\nlineblock = IOBlock([dt(i_r) ~  ω * i_i  - R/L * i_r + 1/L*(u_r_src - u_r_dst),\n                     dt(i_i) ~ -ω * i_r  - R/L * i_i + 1/L*(u_i_src - u_i_dst)],\n                    [u_r_src, u_i_src, u_r_dst, u_i_dst],\n                    [i_r, i_i],\n                    name=:RLLine)\nlineblock = set_p(lineblock, Dict(:R=>NoUnits(Rline), :L=>ustrip(u\"s\", Lline), :ω=>ustrip(u\"rad/s\", ω0)))","category":"page"},{"location":"generated/slack_load/","page":"slack_load","title":"slack_load","text":"This block can be used to create an ODEEdge","category":"page"},{"location":"generated/slack_load/","page":"slack_load","title":"slack_load","text":"edge = ODEEdge(lineblock)\n\nnothing#hide","category":"page"},{"location":"generated/slack_load/#Set-up-the-network","page":"slack_load","title":"Set up the network","text":"","category":"section"},{"location":"generated/slack_load/","page":"slack_load","title":"slack_load","text":"g = SimpleGraph(2)\nadd_edge!(g, 1, 2)\nnd = network_dynamics([slack, load], edge, g)\n\nnothing#hide","category":"page"},{"location":"generated/slack_load/","page":"slack_load","title":"slack_load","text":"We use SteadyStateDiffeq to find the steady state based on an initial guess. The initial guess just contains voltage at both nodes. The load value is given as a parameter to node 2.","category":"page"},{"location":"generated/slack_load/","page":"slack_load","title":"slack_load","text":"uguess = zeros(length(nd.syms))\nuguess[[1,3]] .= 1.0 # set the d component of the slack to 1 from the beginning\np = ([0, NoUnits(Pload)], nothing)\nssprob = SteadyStateProblem(nd, uguess, p)\nu0 = solve(ssprob, DynamicSS(AutoTsit5(Rosenbrock23())))\n\nnothing#hide","category":"page"},{"location":"generated/slack_load/","page":"slack_load","title":"slack_load","text":"Let's ignore this warning for now. I am not sure why the steady state is not completly steady. it nearly is.","category":"page"},{"location":"generated/slack_load/#Simulation","page":"slack_load","title":"Simulation","text":"","category":"section"},{"location":"generated/slack_load/","page":"slack_load","title":"slack_load","text":"We simulate a disconnection of the load at t=0.1 s. This is done using a callback. The callback does 2 things: it sets the reference point P to zero, it sets the currents flowing through the load to zero.","category":"page"},{"location":"generated/slack_load/","page":"slack_load","title":"slack_load","text":"tspan = (0.0, 0.124)\naffect = function (integrator)\n    integrator.p = ([0, 0.0], nothing)\n    integrator.u[[5,6]] .= 0.0\nend\ncb = PresetTimeCallback(0.1, affect)\nprob = ODEProblem(nd, u0, tspan, p; callback=cb)\nsol = solve(prob, Tsit5(),dtmax=0.00001)\nnothing #hide","category":"page"},{"location":"generated/slack_load/","page":"slack_load","title":"slack_load","text":"We may now transformation the results back to a,b,c frame","category":"page"},{"location":"generated/slack_load/","page":"slack_load","title":"slack_load","text":"a,b,c = Tdqinv(sol.t, sol[3,:], sol[4,:])\nnothing#hide","category":"page"},{"location":"generated/slack_load/#Comparison-with-power-factory-results","page":"slack_load","title":"Comparison with power factory results","text":"","category":"section"},{"location":"generated/slack_load/","page":"slack_load","title":"slack_load","text":"Read the Power Facory data and plot for reference","category":"page"},{"location":"generated/slack_load/","page":"slack_load","title":"slack_load","text":"V_base is RMS phase-phase voltage.","category":"page"},{"location":"generated/slack_load/","page":"slack_load","title":"slack_load","text":"V_star = frac1sqrt3 *  V_base\nhatV = sqrtfrac23 * V_base","category":"page"},{"location":"generated/slack_load/","page":"slack_load","title":"slack_load","text":"Therefore, i have to multiply the a, b and c results by sqrt(3/2)","category":"page"},{"location":"generated/slack_load/","page":"slack_load","title":"slack_load","text":"df = CSV.read(joinpath(dirname(pathof(EMTSim)), \"..\", \"data\",\"PowerFactory\", \"Test_EMT.csv\"), DataFrame, skipto=3,\n              header=[:t, :u_1_a, :u_1_b, :u_1_c, :u_2_a, :u_2_b, :u_2_c])\n\nxlims = (0.099,0.124)\nplot(df.t, df.u_2_a; label=\"PowerFactory A\", xlims, color=:lightgray,  linewidth=5)\nplot!(sol.t, a.*sqrt(3/2); label=\"u_2_a\", xlims)\n\nplot!(df.t, df.u_2_b; label=\"PowerFactory B\", color=:lightgray, linewidth=5)\nplot!(sol.t, b.*sqrt(3/2); label=\"u_2_b\")\n\nplot!(df.t, df.u_2_c; label=\"PowerFactory C\", color=:lightgray, linewidth=5)\nplot!(sol.t, c.*sqrt(3/2); label=\"u_2_c\")","category":"page"},{"location":"generated/slack_load/","page":"slack_load","title":"slack_load","text":"In this graph, the PowerFactory solution is light gray and thick behind our solution.","category":"page"},{"location":"generated/slack_load/","page":"slack_load","title":"slack_load","text":"... lets have a closer look","category":"page"},{"location":"generated/slack_load/","page":"slack_load","title":"slack_load","text":"xlims!(0.0995,0.105)","category":"page"},{"location":"generated/slack_load/","page":"slack_load","title":"slack_load","text":"","category":"page"},{"location":"generated/slack_load/","page":"slack_load","title":"slack_load","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = EMTSim","category":"page"},{"location":"#EMTSim","page":"Home","title":"EMTSim","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for EMTSim.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [EMTSim]","category":"page"},{"location":"#NetworkDynamics.ODEEdge","page":"Home","title":"NetworkDynamics.ODEEdge","text":"Conventions: (Anti-)symmetric lines:\n\ninputs:   u_r_src, u_i_src, u_r_dst, u_i_dst\noutputs:  i_r, i_i\ncurrent direction is defined from src to dst\ndst node will receive -i_r, -i_i\n\nAsymmetric lines:\n\ninputs:   u_r_src, u_i_src, u_r_dst, u_i_dst\noutputs:  i_r_src, i_i_src, i_r_dst, i_i_dst\nnot yet implemented. might by tricky with fidutial...\n\n\n\n\n\n","category":"type"},{"location":"#EMTSim.subscript-Union{Tuple{T}, Tuple{T, Int64}} where T<:Union{AbstractString, Symbol}","page":"Home","title":"EMTSim.subscript","text":"subscript(s, i)\n\nAppend symbol or string s with a integer subscript.\n\n\n\n\n\n","category":"method"},{"location":"generated/gridforming/","page":"gridforming","title":"gridforming","text":"EditURL = \"https://github.com/hexaeder/EMTSim.jl/blob/main/examples/gridforming.jl\"","category":"page"},{"location":"generated/gridforming/","page":"gridforming","title":"gridforming","text":"using EMTSim\nusing BlockSystems\nusing ModelingToolkit\nusing NetworkDynamics\nusing Graphs\nusing OrdinaryDiffEq\nusing DiffEqCallbacks\nusing SteadyStateDiffEq\nusing Plots\nusing Unitful\nusing LinearAlgebra\n\nfunction get_rfcA(sym)\n    @variables t x_d(t) x_q(t)\n    @parameters x_r(t) x_i(t) δ(t)\n    blk = IOBlock([x_d ~   x_r * cos(δ) + x_i * sin(δ),\n                   x_q ~ - x_r * sin(δ) + x_i * cos(δ)],\n                  [x_r, x_i, δ],\n                  [x_d, x_q],\n                  name=Symbol(\"rfcA_\"*String(sym)))\n    rename_vars(blk;\n                x_r = Symbol(String(sym)*\"_r\"),\n                x_i = Symbol(String(sym)*\"_i\"),\n                x_d = Symbol(String(sym)*\"_d\"),\n                x_q = Symbol(String(sym)*\"_q\"))\nend\n\nfunction get_rfcB(sym)\n    @variables t x_r(t) x_i(t)\n    @parameters x_d(t) x_q(t) δ(t)\n    blk = IOBlock([x_r ~ x_d * cos(δ) - x_q * sin(δ),\n                   x_i ~ x_d * sin(δ) + x_q * cos(δ)],\n                  [x_d, x_q, δ],\n                  [x_r, x_i],\n                  name=Symbol(\"rfcB_\"*String(sym)))\n    rename_vars(blk;\n                x_r = Symbol(String(sym)*\"_r\"),\n                x_i = Symbol(String(sym)*\"_i\"),\n                x_d = Symbol(String(sym)*\"_d\"),\n                x_q = Symbol(String(sym)*\"_q\"))\nend\n\n####\n#### LCL Filter\n####\n@variables t i_f_r(t) i_f_i(t) i_g_r(t) i_g_i(t) V_C_r(t) V_C_i(t)\n@parameters ω0 Rf Rg Lf Lg C V_I_r(t) V_I_i(t) V_g_r(t) V_g_i(t)\ndt = Differential(t)\n\nLCL = IOBlock([dt(i_f_r) ~ -Rf/Lf*i_f_r + ω0*i_f_i + 1/Lf*(-V_C_r + V_I_r),\n               dt(i_f_i) ~ -Rf/Lf*i_f_i - ω0*i_f_r + 1/Lf*(-V_C_i + V_I_i),\n               dt(i_g_r) ~ -Rg/Lg*i_g_r + ω0*i_g_i + 1/Lg*(V_C_r - V_g_r),\n               dt(i_g_i) ~ -Rg/Lg*i_g_i - ω0*i_g_r + 1/Lg*(V_C_i - V_g_i),\n               dt(V_C_r) ~ 1/C * (i_f_r - i_g_r) + ω0*V_C_i,\n               dt(V_C_i) ~ 1/C * (i_f_i - i_g_i) - ω0*V_C_r],\n              [V_g_r, V_g_i, V_I_r, V_I_i],\n              [i_f_r, i_f_i, i_g_r, i_g_i, V_C_r, V_C_i],\n              name = :LCL)\n\n####\n#### Current Controller\n####\n@variables t γ_d(t) γ_q(t) V_I_d(t) V_I_q(t)\n@parameters KP KI i_f_d(t) i_f_q(t) i_f_ref_d(t) i_f_ref_q(t) Lf\ndt = Differential(t)\n\nCC = IOBlock([dt(γ_d) ~ i_f_ref_d - i_f_d,\n              dt(γ_q) ~ i_f_ref_q - i_f_q,\n              V_I_d ~  Lf*ω0*i_f_q + KP*(i_f_ref_d - i_f_d) + KI*γ_d,\n              V_I_q ~ -Lf*ω0*i_f_d + KP*(i_f_ref_q - i_f_q) + KI*γ_q],\n             [i_f_d, i_f_q, i_f_ref_d, i_f_ref_q],\n             [V_I_d, V_I_q],\n             name=:CC)\n\n@variables t γ_d(t) γ_q(t) i_f_ref_d(t)  i_f_ref_q(t)\n@parameters KP KI F V_C_d(t) V_C_q(t) V_C_ref_d(t) V_C_ref_q(t) i_g_d(t) i_g_q(t) ω0 C\ndt = Differential(t)\n\n####\n#### Voltage Controller\n####\nVC = IOBlock([dt(γ_d) ~ V_C_ref_d - V_C_d,\n              dt(γ_q) ~ V_C_ref_q - V_C_q,\n              i_f_ref_d ~ F*i_g_d + C*ω0*V_C_q + KP*(V_C_ref_d - V_C_d) + KI*γ_d,\n              i_f_ref_q ~ F*i_g_q - C*ω0*V_C_d + KP*(V_C_ref_q - V_C_q) + KI*γ_q],\n             [i_g_d, i_g_q, V_C_d, V_C_q, V_C_ref_d, V_C_ref_q],\n             [i_f_ref_d, i_f_ref_q],\n             name=:VC)\n\n\n####\n#### RFC Blocks\n####\nrfc_i_f = get_rfcA(:i_f)\nrfc_i_g = get_rfcA(:i_g)\nrfc_V_C = get_rfcA(:V_C)\nrfc_V_I = get_rfcB(:V_I)\n\n####\n#### System Creation\n####\nsystem = IOSystem(:autocon,\n                  [LCL,CC, VC, rfc_i_f, rfc_i_g, rfc_V_C, rfc_V_I],\n                  outputs=[LCL.i_g_r, LCL.i_g_i],\n                  globalp=[:δ, :C, :ω0, :Rf, :Rg, :Lf, :Lg],\n                  name=:inv)\n\nsys = connect_system(system)\nsys = set_input(sys, :δ=>0)","category":"page"},{"location":"generated/gridforming/","page":"gridforming","title":"gridforming","text":"sys = setinput(sys, :VCrefd=>1) sys = setinput(sys, :VCrefq=>0)","category":"page"},{"location":"generated/gridforming/","page":"gridforming","title":"gridforming","text":"params = Dict(\n    :VC₊KI => 1,\n    :CC₊KI => 1,\n    :VC₊KP => 1,\n    :CC₊KP => 1,\n    :F => 1,\n    :Rf => 0.01,\n    :Rg => 0.01,\n    :Lf => 10e-6,\n    :Lg => 10e-6,\n    :C => 1e-6,\n    :ω0 => 2π*50,\n)\n\nsysp = set_p(sys, params) |> simplify\n\nA, B, C, D = identify_lti(sysp)\nA = fixdiv(A)\n\n\nss = StateSpace(A, B, Matrix(I,10,10), zeros(10,4))\n\nOG = gram(ss,:o)\nisposdef(OG)\nCG = gram(ss,:c)\nisposdef(CG)\n\nsysbt, G, T = baltrunc(ss)\nbodeplot(ss)\n\npzmap(ss)\n\neigen(A)\n\n\nsysclosed = set_input(sysp, :V_g_r=>0.8)\nsysclosed = set_input(sysclosed, :V_g_i=>0.0)\n\nf = ODEFunction(sysclosed)\nu0 = zeros(length(f.syms))\nprob = ODEProblem(f, u0, (0, 10.))\nsol = solve(prob, Rodas5())\n\nf.syms\n\nplot(sol, vars=[:i_g_r, :i_g_i])","category":"page"},{"location":"generated/gridforming/","page":"gridforming","title":"gridforming","text":"plot!(sol, vars=[:ifr, :ifi])","category":"page"},{"location":"generated/gridforming/","page":"gridforming","title":"gridforming","text":"plot(sol, vars=[:V_C_r, :V_C_i])\nplot(sol, vars=[:V_C_r, :V_C_i])\nplot(sol, vars=[:CC₊γ_d, :CC₊γ_q])\nplot(sol, vars=[:VC₊γ_d, :VC₊γ_q])\n\nxlims!(0, 0.001)\n\nf.syms\neigen(A)\n\nCtrb = ctrb(A, B)\nrank(Ctrb)\n\ndet(Ctrb)\n\nObsv = obsv(A, I)\nrank(Obsv)\nObsv\n\nrank(Obsv[1:10,:])\nsvd(Obsv[1:10,:])\n\nsvd(Ctrb)\n\nrank(Obsv)\n\nrank(Obsv)\n\nMatrix(I, 4, 4)","category":"page"},{"location":"generated/gridforming/","page":"gridforming","title":"gridforming","text":"","category":"page"},{"location":"generated/gridforming/","page":"gridforming","title":"gridforming","text":"This page was generated using Literate.jl.","category":"page"}]
}
